#include<iostream>
#include<cmath>
using namespace std;

#include<eigen3/Eigen/Core>
#include<eigen3/Eigen/Geometry>

#include "sophus/so3.h"
#include "sophus/se3.h"

//#include "Sophus/sophus/se3.h"


int main( int argc, char**argv)

{
  // roation matrix: rotate 90 along z axis, generated by angle axis
    Eigen::Matrix3d YC_R = Eigen::AngleAxisd(M_PI/2, Eigen::Vector3d(0,0,1)).toRotationMatrix();
    cout<<"YC_R = "<<YC_R<<endl;

    //note here have an overload in sophus SO3 class
    Sophus::SO3 SO3_R(YC_R); //sophus::SO(3) can generate from rotation matrix
    Sophus::SO3 SO3_v(0,0,M_PI/2); //or  get SO3 from rotation Vector, theta*a
    Eigen::Quaterniond q(YC_R);   // or get SO3 from quaternond **note on initilization
    Sophus::SO3 SO3_q(q);

    //***NOTE: print as so(3), NOT SO(3)
    // although print as so3(3d vector), still a 3x3 (R)

    cout<<"SO(3) from matrix:"<<SO3_R<<endl;
    cout<<"SO(3) from matrix:"<<SO3_v<<endl;
    cout<<"SO(3) from matrix:"<<SO3_q<<endl;
    cout<<" real SO(3) in R form:---"<<YC_R.matrix()<<endl;
    cout<<" real so(3) in matrix form 3x3:---"<<SO3_q.matrix()<<endl;







    //get Lie Alg from expo map
    // careful about so3 & so3 hat
    //R= exp(phi^)
    //log(R)=phi^

    Eigen::Vector3d so3 =SO3_R.log();
    cout<<"so3="<<so3.transpose()<<endl;

    // hat ^ is vector to skew-symm matrix
    cout<<"so3 hat="<<Sophus::SO3::hat(so3)<<endl; //3x3, different from R


    //similarly, vee is matrix to vector
    cout<<"so3 hat vee="<<Sophus::SO3::vee(Sophus::SO3::hat(so3)).transpose()<<endl;


    // delta R model update
    // dont understand why multiply exp(phi) instead of exp(phi_hat)
    Eigen::Vector3d update_so3(1e-4,0,0);
    Sophus::SO3 SO3_updated =Sophus::SO3::exp(update_so3)*SO3_R; //left multiply update
    cout<<"SO3 updated = "<<SO3_updated<<endl; //3x1 vector
    cout<<"SO3 updated matrix form = "<<SO3_updated.matrix()<<endl; //3x3 matrix R


    cout<<"****************************"<<endl;

    // similar thing happens to SE(3)
    Eigen::Vector3d t(1,0,0); //move along x axis by 1(translation)
    Sophus::SE3 SE3_Rt(YC_R,t); // get SE(3) from R,t
    Sophus::SE3 SE3_qt(YC_R,t); //get SE(3) from q,t
    cout<<"SE3 from R,t ="<<SE3_Rt<<endl; //2x3 matrix
    cout<<"SE3 from q,t ="<<SE3_qt<<endl;

    //Lie Alg is a 6d vector, typedef for convience

    typedef Eigen::Matrix<double,6,1> Vector6d;
    Vector6d se3 =SE3_Rt.log();
    cout<<"se3="<<se3<<endl;  // 6x1, is the element of se(3)
    // in sophus, se(3) consists move and rotate, move 1st, like in the book
    // similarly, hat and vee
    cout<<"se3 hat="<<endl<<Sophus::SE3::hat(se3)<<endl;  //4x4 se3 hat
    cout<<"se3 hat vee="<<endl<<Sophus::SE3::vee(Sophus::SE3::hat(se3)).transpose()<<endl; //6x1

    // show how to update , left mulytiply
    Vector6d update_se3; //update value
    update_se3.setZero();

    update_se3(0,0) =1e-4d;
    Sophus::SE3 SE3_updated =Sophus::SE3::exp(update_se3)*SE3_Rt;
    cout<<"SE3 updated ="<<endl<<SE3_updated.matrix()<<endl;




    return 0;



}